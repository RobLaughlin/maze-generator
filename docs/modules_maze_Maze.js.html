<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: modules/maze/Maze.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: modules/maze/Maze.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import GridIndex from "./GridIndex";
import Cell from "./Cell";

/**
 * @module Maze
 */

 /**
  * 2D Grid of {@link Cell} objects containing maze data generated using explicit recursive depth-first search.
  * 
  * Explanation from Wikipedia as follows:
  * 
  * A disadvantage of the recursive implicit stack approach is a large depth of recursion.
  * In the worst case, the routine may need to recur on every cell of the area being processed, which may 
  * exceed the maximum recursion stack depth in many environments. As a solution, the same backtracking method 
  * can be implemented with an explicit stack, which is usually allowed to grow much bigger with no harm.
  * 
  * [Wikipedia]{@link https://en.wikipedia.org/wiki/Maze_generation_algorithm#Iterative_implementation}
  * 
  * Algorithm:
  * 1. Choose the initial cell, mark it as visited and push it to the stack.
  * 2. While the stack is not empty.
  *     1. Pop a cell from the stack and make it a current cell.
  *     2. If the current cell has any neighbours which have not been visited.
  *         1. Push the current cell to the stack.
  *         2. Choose one of the unvisited neighbours.
  *         3. Remove the wall between the current cell and the chosen cell.
  *         4. Mark the chosen cell as visited and push it to the stack.
  */
class Maze {
    constructor(rows, columns) {
        /** @property {int} rows Maximum number of rows in the maze. */
        this.rows = rows;

        /** @property {int} columns Maximum number of columns in the maze. */
        this.columns = columns;

        /** @property {Array.Cell[]} cells 2D Array of [Cells]{@link Cell} */
        this.cells = Array.from({length: rows}, (_, r) =>
            Array.from({length: columns}, (_, c) => (
                new Cell(new GridIndex(r, c))
            ))
        );
    }
}

Maze.prototype.validCellIndex = function(index) {
    return  (index.row &lt; this.rows)         &amp;&amp; 
            (index.column &lt; this.columns)   &amp;&amp;
            (index.row >= 0)                &amp;&amp;
            (index.column >= 0);
};

Maze.prototype.getUnvisitedNeighbors = function(indices) {
    let neighbors = [];

    indices.forEach((i, wall) => {
        if (this.validCellIndex(i)) {
            let cell = this.cells[i.row][i.column];
            if (!cell.visited) { neighbors.push([cell, wall]); }
        }
    });

    return neighbors;
};

Maze.prototype.generator = function* (row, column) {
    let index = new GridIndex(row, column);
    if (!this.validCellIndex(index)) { throw RangeError ('Starting index out of range.'); }

    let stack = [];
    let initialCell = this.cells[index.row][index.column];
    initialCell.visited = true;
    stack.push(initialCell);
    yield initialCell;

    while (stack.length > 0) {
        let currentCell = stack.pop();
        let neighbors = this.getUnvisitedNeighbors(currentCell.getNeighborIndices());

        if (neighbors.length > 0) {
            let i = Math.floor(Math.random() * neighbors.length);
            let nextCell = neighbors[i][0];
            let wall = neighbors[i][1];
            
            nextCell.visited = true;
            nextCell.toggleOpposite(wall, false);
            stack.push(currentCell);
            stack.push(nextCell);
            yield nextCell;
        }
    }
};

export default Maze;</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-Maze.html">Maze</a></li></ul><h3>Classes</h3><ul><li><a href="Box.html">Box</a></li><li><a href="Cell.html">Cell</a></li><li><a href="GridIndex.html">GridIndex</a></li><li><a href="module-Maze-Maze.html">Maze</a></li><li><a href="Wall.html">Wall</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.6</a> on Thu Oct 01 2020 01:08:54 GMT-0700 (Pacific Daylight Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
